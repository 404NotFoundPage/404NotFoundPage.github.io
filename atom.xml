<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢文锐</title>
  <icon>https://www.gravatar.com/avatar/be0690ad30516f82772b1c75fa56acee</icon>
  <subtitle>四海翻腾云水怒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="kyrie.github.io/"/>
  <updated>2020-09-27T06:50:23.782Z</updated>
  <id>kyrie.github.io/</id>
  
  <author>
    <name>谢文锐</name>
    <email>xwr204000@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数柯里化</title>
    <link href="kyrie.github.io/2020/09/27/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>kyrie.github.io/2020/09/27/函数柯里化/</id>
    <published>2020-09-27T06:16:59.000Z</published>
    <updated>2020-09-27T06:50:23.782Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><ul><li>打印一个函数时,默认会调用toString()方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">...argg</span>) </span>&#123;</span><br><span class="line">        args.push( ...argg )</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fn.toString = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">pre, current</span>) =&gt;</span> pre + current);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line">curry(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="或者是下面这种方式"><a href="#或者是下面这种方式" class="headerlink" title="或者是下面这种方式"></a>或者是下面这种方式</h4><ul><li>valueOf()方法同样可行<a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">...argg</span>) </span>&#123;</span><br><span class="line">        args.push( ...argg )</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fn.toString = <span class="literal">null</span>;</span><br><span class="line">    fn.valueOf = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">pre, current</span>) =&gt;</span> pre + current);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line">curry(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h6 id="两个方法一般是交由JS去隐式调用-来满足不同的运算-大致总结如下："><a href="#两个方法一般是交由JS去隐式调用-来满足不同的运算-大致总结如下：" class="headerlink" title="两个方法一般是交由JS去隐式调用,来满足不同的运算,大致总结如下："></a>两个方法一般是交由JS去隐式调用,来满足不同的运算,大致总结如下：</h6><ul><li>1、valueOf()偏向于运算，toString()偏向于显示</li><li>2、对象转换时，优先调用toString()</li><li>3、强转字符串的情况下，优先调用toString()方法；强转数字的情况下优先调用valueOf()</li><li>4、正常情况下，优先调用toString()</li><li>5、在有运算操作符的情况下valueOf()的优先级高于toString(),但是当调用valueOf()方法无法运算后还是会再调用toString()方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;函数柯里化&quot;&gt;&lt;a href=&quot;#函数柯里化&quot; class=&quot;headerlink&quot; title=&quot;函数柯里化&quot;&gt;&lt;/a&gt;函数柯里化&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;打印一个函数时,默认会调用toString()方法&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;curry&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;...arg&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; args = arg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fn = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;...argg&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        args.push( ...argg )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fn;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fn.toString = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; args.reduce(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;pre, current&lt;/span&gt;) =&amp;gt;&lt;/span&gt; pre + current);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fn;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;curry(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;或者是下面这种方式&quot;&gt;&lt;a href=&quot;#或者是下面这种方式&quot; class=&quot;headerlink&quot; title=&quot;或者是下面这种方式&quot;&gt;&lt;/a&gt;或者是下面这种方式&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;valueOf()方法同样可行
    
    </summary>
    
    
      <category term="js" scheme="kyrie.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>参考阿里的移动端适配</title>
    <link href="kyrie.github.io/2018/08/25/%E9%98%BF%E9%87%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    <id>kyrie.github.io/2018/08/25/阿里移动端适配/</id>
    <published>2018-08-25T09:48:17.000Z</published>
    <updated>2018-08-28T02:14:50.869Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考的阿里的移动端适配方案"><a href="#参考的阿里的移动端适配方案" class="headerlink" title="参考的阿里的移动端适配方案."></a>参考的阿里的移动端适配方案.</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">    &lt;script&gt;</span><br><span class="line">              ;</span><br><span class="line">(function(win, lib) &#123;</span><br><span class="line">    var doc = win.document;</span><br><span class="line">    var docEl = doc.documentElement;</span><br><span class="line">    var metaEl = doc.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;);</span><br><span class="line">    var flexibleEl = doc.querySelector(&apos;meta[name=&quot;flexible&quot;]&apos;);</span><br><span class="line">    var dpr = 0;</span><br><span class="line">    var scale = 0;</span><br><span class="line">    var tid;</span><br><span class="line">    var flexible = lib.flexible || (lib.flexible = &#123;&#125;);</span><br><span class="line">    if (metaEl) &#123;</span><br><span class="line">        console.warn(&apos;将根据已有的meta标签来设置缩放比例&apos;);</span><br><span class="line">        var match = metaEl.getAttribute(&apos;content&apos;).match(/initial\-scale=([\d\.]+)/);</span><br><span class="line">        if (match) &#123;</span><br><span class="line">            scale = parseFloat(match[1]);</span><br><span class="line">            dpr = parseInt(1 / scale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (flexibleEl) &#123;</span><br><span class="line">        var content = flexibleEl.getAttribute(&apos;content&apos;);</span><br><span class="line">        if (content) &#123;</span><br><span class="line">            var initialDpr = content.match(/initial\-dpr=([\d\.]+)/);</span><br><span class="line">            var maximumDpr = content.match(/maximum\-dpr=([\d\.]+)/);</span><br><span class="line">            if (initialDpr) &#123;</span><br><span class="line">                dpr = parseFloat(initialDpr[1]);</span><br><span class="line">                scale = parseFloat((1 / dpr).toFixed(2));</span><br><span class="line">            &#125;</span><br><span class="line">            if (maximumDpr) &#123;</span><br><span class="line">                dpr = parseFloat(maximumDpr[1]);</span><br><span class="line">                scale = parseFloat((1 / dpr).toFixed(2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!dpr &amp;&amp; !scale) &#123;</span><br><span class="line">        var isAndroid = win.navigator.appVersion.match(/android/gi);</span><br><span class="line">        var isIPhone = win.navigator.appVersion.match(/iphone/gi);</span><br><span class="line">        var devicePixelRatio = win.devicePixelRatio;</span><br><span class="line">        if (isIPhone) &#123;</span><br><span class="line">            // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案</span><br><span class="line">            if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123;</span><br><span class="line">                dpr = 3;</span><br><span class="line">            &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)) &#123;</span><br><span class="line">                dpr = 2;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dpr = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其他设备下，仍旧使用1倍的方案</span><br><span class="line">            dpr = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        scale = 1 / dpr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    docEl.setAttribute(&apos;data-dpr&apos;, dpr);</span><br><span class="line">    if (!metaEl) &#123;</span><br><span class="line">        metaEl = doc.createElement(&apos;meta&apos;);</span><br><span class="line">        metaEl.setAttribute(&apos;name&apos;, &apos;viewport&apos;);</span><br><span class="line">        metaEl.setAttribute(&apos;content&apos;, &apos;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;);</span><br><span class="line">        if (docEl.firstElementChild) &#123;</span><br><span class="line">            docEl.firstElementChild.appendChild(metaEl);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var wrap = doc.createElement(&apos;div&apos;);</span><br><span class="line">            wrap.appendChild(metaEl);</span><br><span class="line">            doc.write(wrap.innerHTML);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function refreshRem() &#123;</span><br><span class="line">        var height = window.innerHeight;</span><br><span class="line">        var width = docEl.getBoundingClientRect().width;</span><br><span class="line">        if (height &lt; width) &#123;</span><br><span class="line">            width = height</span><br><span class="line">        &#125;</span><br><span class="line">        if (width / dpr &gt; 540) &#123;</span><br><span class="line">            width = 540 * dpr;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(width);</span><br><span class="line">        var rem = width / 10;</span><br><span class="line">        docEl.style.fontSize = rem + &apos;px&apos;;</span><br><span class="line">        console.log(rem);</span><br><span class="line">        flexible.rem = win.rem = rem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    win.addEventListener(&apos;resize&apos;, function() &#123;</span><br><span class="line">        clearTimeout(tid);</span><br><span class="line">        tid = setTimeout(refreshRem, 300);</span><br><span class="line">    &#125;, false);</span><br><span class="line">    win.addEventListener(&apos;pageshow&apos;, function(e) &#123;</span><br><span class="line">        if (e.persisted) &#123;</span><br><span class="line">            clearTimeout(tid);</span><br><span class="line">            tid = setTimeout(refreshRem, 300);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line"></span><br><span class="line">    if (doc.readyState === &apos;complete&apos;) &#123;</span><br><span class="line">        doc.body.style.fontSize = 12 * dpr + &apos;px&apos;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        doc.addEventListener(&apos;DOMContentLoaded&apos;, function(e) &#123;</span><br><span class="line">            doc.body.style.fontSize = 12 * dpr + &apos;px&apos;;</span><br><span class="line">        &#125;, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    refreshRem();</span><br><span class="line"></span><br><span class="line">    flexible.dpr = win.dpr = dpr;</span><br><span class="line">    flexible.refreshRem = refreshRem;</span><br><span class="line">    flexible.rem2px = function(d) &#123;</span><br><span class="line">        var val = parseFloat(d) * this.rem;</span><br><span class="line">        if (typeof d === &apos;string&apos; &amp;&amp; d.match(/rem$/)) &#123;</span><br><span class="line">            val += &apos;px&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">    flexible.px2rem = function(d) &#123;</span><br><span class="line">        var val = parseFloat(d) / this.rem;</span><br><span class="line">        if (typeof d === &apos;string&apos; &amp;&amp; d.match(/px$/)) &#123;</span><br><span class="line">            val += &apos;rem&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)(window, window[&apos;lib&apos;] || (window[&apos;lib&apos;] = &#123;&#125;));</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考的阿里的移动端适配方案&quot;&gt;&lt;a href=&quot;#参考的阿里的移动端适配方案&quot; class=&quot;headerlink&quot; title=&quot;参考的阿里的移动端适配方案.&quot;&gt;&lt;/a&gt;参考的阿里的移动端适配方案.&lt;/h3&gt;
    
    </summary>
    
      <category term="移动端" scheme="kyrie.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="js" scheme="kyrie.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号获取手机经纬度</title>
    <link href="kyrie.github.io/2018/08/18/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E7%BB%8F%E7%BA%AC%E5%BA%A6/"/>
    <id>kyrie.github.io/2018/08/18/微信公众号获取手机经纬度/</id>
    <published>2018-08-18T03:56:41.000Z</published>
    <updated>2018-08-18T04:47:46.214Z</updated>
    
    <content type="html"><![CDATA[<h4 id="直接贴代码"><a href="#直接贴代码" class="headerlink" title="直接贴代码"></a>直接贴代码</h4><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.2.0.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="第二部配置"><a href="#第二部配置" class="headerlink" title="第二部配置"></a>第二部配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        wx.config(&#123;</span><br><span class="line">            debug: false,</span><br><span class="line">            appId: &apos;&lt;?=$signPackage[&quot;appId&quot;];?&gt;&apos;,//公众号的唯一标识</span><br><span class="line">            timestamp: &apos;&lt;?=$signPackage[&quot;timestamp&quot;];?&gt;&apos;,//生成签名的时间戳</span><br><span class="line">            nonceStr: &apos;&lt;?=$signPackage[&quot;nonceStr&quot;];?&gt;&apos;,//生成签名的随机串</span><br><span class="line">            signature: &apos;&lt;?=$signPackage[&quot;signature&quot;];?&gt;&apos;,</span><br><span class="line">            jsApiList: [&apos;checkJsApi&apos;,</span><br><span class="line">                &apos;onMenuShareTimeline&apos;,</span><br><span class="line">                &apos;onMenuShareAppMessage&apos;,</span><br><span class="line">                &apos;onMenuShareQQ&apos;,</span><br><span class="line">                &apos;onMenuShareWeibo&apos;,</span><br><span class="line">                &apos;chooseImage&apos;,</span><br><span class="line">                &apos;previewImage&apos;,</span><br><span class="line">                &apos;uploadImage&apos;,</span><br><span class="line">                &apos;downloadImage&apos;,</span><br><span class="line">                &apos;getLocation&apos;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        wx.ready(function()&#123;</span><br><span class="line"></span><br><span class="line">            wx.onMenuShareTimeline(&#123;     //分享</span><br><span class="line">                title: &apos;&#123;$share[&quot;title&quot;]&#125;&apos;,</span><br><span class="line">                link:&apos;&#123;$share[&quot;url&quot;]&#125;&apos;,</span><br><span class="line">                imgUrl:&apos;&#123;$share[&quot;image&quot;]&#125;&apos;,</span><br><span class="line">                success: function () &#123;</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                cancel: function () &#123;&#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            wx.onMenuShareAppMessage(&#123;    //分享</span><br><span class="line">                title: &apos;&#123;$share[&quot;title&quot;]&#125;&apos;,</span><br><span class="line">                desc: &apos;&#123;$share[&quot;desc&quot;]&#125;&apos;,</span><br><span class="line">                link:&apos;&#123;$share[&quot;url&quot;]&#125;&apos;,</span><br><span class="line">                imgUrl:&apos;&#123;$share[&quot;image&quot;]&#125;&apos;,</span><br><span class="line">                success: function () &#123;</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                cancel: function () &#123;&#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">             wx.getLocation(&#123;    // 获取地理位置经纬度信息;</span><br><span class="line">                    type: &apos;wgs84&apos;, // 默认为wgs84的gps坐标，如果要返回直接给openLocation用的火星坐标，可传入&apos;gcj02&apos;</span><br><span class="line">                    success: function (res) &#123;</span><br><span class="line">                        conso.log(res)</span><br><span class="line">                        lng = res.latitude; // 纬度，浮点数，范围为90 ~ -90</span><br><span class="line">                        lat = res.longitude; // 经度，浮点数，范围为180 ~ -180。</span><br><span class="line">                        if(!latitude || !longtude)&#123;</span><br><span class="line">                            layer.closeAll();</span><br><span class="line">                            layer.open(&#123;</span><br><span class="line">                                content:&quot;请确认您已经开启了GPS，并且同意微信获取您的地理位置&quot;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        console.log(latitude + &quot;__&quot;+longtude )</span><br><span class="line">                    &#125;,</span><br><span class="line">                    cancel: function (res) &#123;</span><br><span class="line">                        console.log(&apos;取消&apos;)</span><br><span class="line">                        layer.closeAll();</span><br><span class="line">                        layer.open(&#123;</span><br><span class="line">                            content:&quot;请确认您已经开启了GPS，并且同意微信获取您的地理位置&quot;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    fail: function (res)&#123;</span><br><span class="line">                        console.log(&apos;失败&apos;)</span><br><span class="line">                        layer.closeAll();</span><br><span class="line">                        layer.open(&#123;</span><br><span class="line">                            content:&quot;地理位置获取失败，请确认您已经开启了GPS，并且同意微信获取您的地理位置&quot;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>获取地址时要在<code>wx.ready({})</code>里面请求;</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;直接贴代码&quot;&gt;&lt;a href=&quot;#直接贴代码&quot; class=&quot;headerlink&quot; title=&quot;直接贴代码&quot;&gt;&lt;/a&gt;直接贴代码&lt;/h4&gt;&lt;h2 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=&quot;第一步&quot;&gt;&lt;/a&gt;第一步&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src=&amp;quot;http://res.wx.qq.com/open/js/jweixin-1.2.0.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="wx公众号" scheme="kyrie.github.io/categories/wx%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
    
      <category term="wx公众号" scheme="kyrie.github.io/tags/wx%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>react入门</title>
    <link href="kyrie.github.io/2018/05/14/react%E7%AC%94%E8%AE%B0/"/>
    <id>kyrie.github.io/2018/05/14/react笔记/</id>
    <published>2018-05-14T11:01:17.000Z</published>
    <updated>2018-05-21T05:07:27.776Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目前是处于刚学习react阶段，暂时整理如下资料，后续会继续修改和更新</strong><br><a id="more"></a></p><h3 id="认识React"><a href="#认识React" class="headerlink" title="认识React"></a>认识React</h3><blockquote><ul><li>声明式设计 −React采用声明范式，可以轻松描述应用。</li><li>高效 −React采用虚拟DOM.</li><li>灵活 −React可以与已知的库或框架很好地配合。</li><li>JSX − JSX 是 JavaScript 语法的扩展。</li><li>组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</li><li>单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</li></ul></blockquote><h3 id="快速构建-React-开发环境"><a href="#快速构建-React-开发环境" class="headerlink" title="快速构建 React 开发环境"></a>快速构建 React 开发环境</h3><p>安装<code>create-react-app</code>的方式也非常简单，可以直接使用npm命令进行全局安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br><span class="line">create-react-app my-app</span><br><span class="line">cd my-app/</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure></p><p>执行完上述命令之后，你可以直接打开<code>http://localhost:3000</code>，即可以看到你React APP的运行效果。此时也是处于开发模式下，如果你要进行发布，则使用<code>npm run build</code>进行编译。<br>如果是使用<code>npm start</code>来启动配置，那么自动会进入开发模式，此时热替换是处于自动激活状态，你也可以实时地在界面或者命令行中看到错误提示<br>如果使用<code>npm run build</code>来编译得到生产环境，此时代码会被编译到build目录下，此时会自动将整个应用打包发布，它会自动使用<code>Webpack</code>控件进行优化与压缩</p><h3 id="React-JSX"><a href="#React-JSX" class="headerlink" title="React JSX"></a>React JSX</h3><p>React 使用 JSX 来替代常规的 JavaScript。<br>JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。<br>我们不需要一定使用 JSX，但它有以下优点：</p><blockquote><ul><li>JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。</li><li>它是类型安全的，在编译过程中就能发现错误。</li><li>使用 JSX 编写模板更加简单快速。<br>为什么引用jsx语法？</li><li>解决了创建虚拟dom成本过大的问题<br>什么是jsx语法？</li><li>简单地说，就是jsx语法让我们可以再js中写xhtml</li></ul></blockquote><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="组件是做什么的？"><a href="#组件是做什么的？" class="headerlink" title="组件是做什么的？"></a>组件是做什么的？</h4><p>如果一个虚拟dom复用多次的时候，通常我们将它封装在一个组件当中，通常用组件封装一组虚拟dom，这一组虚拟dom通常称他为虚拟dom树。</p><h4 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h4><p>React推出后，出于不同的原因先后出现三种定义react组件的方式，殊途同归；具体的三种方式：</p><blockquote><ul><li>函数式定义的<strong>无状态</strong>组件</li><li>es5原生方式<code>React.createClass</code>定义的组件</li><li>es6形式的<code>extends React.Component</code>定义的组件</li></ul></blockquote><p>现在主要采用<code>React.Component</code>是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，相对于 <code>React.createClass</code>可以更好实现代码复用，创建代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123; Component &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">class Commentlist extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        ) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Commentlist;</span><br></pre></td></tr></table></figure></p><p>那么，组件创建完成之后，我们整理一下组件的属性</p><h5 id="props属性"><a href="#props属性" class="headerlink" title="props属性"></a>props属性</h5><p>props属性是什么？</p><blockquote><ul><li>和html给标签添加一个类一样，对于完全一致的统一组件他们暂时的样式是完全一致的，给其中一个添加一些属性，此时这个组件展示的结果就可能会不同，所以react提出了组件属性的概念。<br>如何添加props属性？</li><li>在jsx中为组件添加属性跟html中添加属性的方法是一模一样的，只不过react组件可以执行插值(就是可以将js中数据添加到组件中)</li></ul></blockquote><h5 id="state属性"><a href="#state属性" class="headerlink" title="state属性"></a>state属性</h5><p>state属性是什么？</p><blockquote><ul><li>组件内部通常会维护一个状态，这个属性就是state，和props一样，我们都可以更改他是我们说props是在组建创建是传递的属性值不同而决定的，因此以后通常是更改不了的子组件）state通常是在产生交互时候改变的，一次她的改变永远伴随着一个交互state，props的改变都会执行一次render方法来重新渲染组件，组件是否更改是由虚拟d没有改变决定，如果虚拟dom改变了组件就会渲染。</li></ul></blockquote><h5 id="state与props的区别"><a href="#state与props的区别" class="headerlink" title="state与props的区别"></a>state与props的区别</h5><p><strong>state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据。</strong></p><h5 id="正确修改state"><a href="#正确修改state" class="headerlink" title="正确修改state"></a>正确修改state</h5><p>直接修改state，组件并不会重新重发render。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 错误</span><br><span class="line">this.state.title = &apos;React&apos;;</span><br></pre></td></tr></table></figure></p><p>正确的修改方式是使用setState():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;title: &apos;React&apos;&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="State-的更新是异步的"><a href="#State-的更新是异步的" class="headerlink" title="State 的更新是异步的"></a>State 的更新是异步的</h5><p>调用setState，组件的state并不会立即改变，setState只是把要修改的状态放入一个队列中，React会优化真正的执行时机，并且React会出于性能原因，可能会将多次setState的状态修改合并成一次状态修改。所以不要依赖当前的State，计算下个State。当真正执行状态修改时，依赖的this.state并不能保证是最新的State，因为React会把多次State的修改合并成一次，这时，this.state将还是这几次State修改前的State。另外需要注意的事，同样不能依赖当前的Props计算下个状态，因为Props一般也是从父组件的State中获取，依然无法确定在组件状态更新时的值。</p><h4 id="React组件生命周期小结"><a href="#React组件生命周期小结" class="headerlink" title="React组件生命周期小结"></a>React组件生命周期小结</h4><p>这几个生命周期相关的函数有：</p><ul><li><p>构造函数，在创建组件的时候调用一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor(props, context)</span><br></pre></td></tr></table></figure></li><li><p>在组件挂载之前调用一次。如果在这个函数里面调用setState，本次的render函数可以看到更新后的state，并且只渲染一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void componentWillMount()</span><br></pre></td></tr></table></figure></li><li><p>在组件挂载之后调用一次。这个时候，子主键也都挂载好了，可以在这里使用refs。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void componentDidMount()</span><br></pre></td></tr></table></figure></li><li><p>props是父组件传递给子组件的。父组件发生render的时候子组件就会调用componentWillReceiveProps（不管props有没有更新，也不管父子组件之间有没有数据交换）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void componentWillReceiveProps(nextProps)</span><br></pre></td></tr></table></figure></li><li><p>组件挂载之后，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件。默认返回true，需要重新render。在比较复杂的应用里，有一些数据的改变并不影响界面展示，可以在这里做判断，优化渲染效率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure></li><li><p>shouldComponentUpdate返回true或者调用forceUpdate之后，componentWillUpdate会被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void componentWillUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure></li><li><p>除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void componentDidUpdate()</span><br></pre></td></tr></table></figure></li></ul><p><strong>componentWillMount、componentDidMount和componentWillUpdate、componentDidUpdate可以对应起来。区别在于，前者只有在挂载的时候会被调用；而后者在以后的每次更新渲染之后都会被调用。</strong></p><ul><li><p>render是一个React组件所必不可少的核心函数（上面的其它函数都不是必须的）。记住，不要在render里面修改state。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactElement render()</span><br></pre></td></tr></table></figure></li><li><p>组件被卸载的时候调用。一般在componentDidMount里面注册的事件需要在这里删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void componentWillUnmount()</span><br></pre></td></tr></table></figure></li></ul><h4 id="更新方式"><a href="#更新方式" class="headerlink" title="更新方式"></a>更新方式</h4><p>在react中，触发render的有4条路径。<br>以下假设<code>shouldComponentUpdate</code>都是按照默认返回true的方式。</p><blockquote><ul><li>首次渲染Initial Render</li><li>调用this.setState （并不是一次setState会触发一次render，React可能会合并操作，再一次性进行render）</li><li>父组件发生更新（一般就是props发生改变，但是就算props没有改变或者父子组件之间没有数据交换也会触发render）</li><li>调用this.forceUpdate</li></ul></blockquote><p>下面是对React组件四条更新路径地总结：<br><img src="https://upload-images.jianshu.io/upload_images/1814354-4bf62e54553a32b7.png?imageMogr2/auto-orient/" alt="生命周期图片"></p><p>最后来个测试例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">class LifeCycle extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        alert(&quot;Initial render&quot;);</span><br><span class="line">        alert(&quot;constructor&quot;);</span><br><span class="line">        this.state = &#123;str: &quot;hello&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">        alert(&quot;componentWillMount&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        alert(&quot;componentDidMount&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">        alert(&quot;componentWillReceiveProps&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shouldComponentUpdate() &#123;</span><br><span class="line">        alert(&quot;shouldComponentUpdate&quot;);</span><br><span class="line">        return true;        // 记得要返回true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUpdate() &#123;</span><br><span class="line">        alert(&quot;componentWillUpdate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidUpdate() &#123;</span><br><span class="line">        alert(&quot;componentDidUpdate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        alert(&quot;componentWillUnmount&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTheState() &#123;</span><br><span class="line">        let s = &quot;hello&quot;;</span><br><span class="line">        if (this.state.str === s) &#123;</span><br><span class="line">            s = &quot;HELLO&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            str: s</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forceItUpdate() &#123;</span><br><span class="line">        this.forceUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        alert(&quot;render&quot;);</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;span&gt;&#123;&quot;Props:&quot;&#125;&lt;h2&gt;&#123;parseInt(this.props.num)&#125;&lt;/h2&gt;&lt;/span&gt;</span><br><span class="line">                &lt;br /&gt;</span><br><span class="line">                &lt;span&gt;&#123;&quot;State:&quot;&#125;&lt;h2&gt;&#123;this.state.str&#125;&lt;/h2&gt;&lt;/span&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Container  extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            num: Math.random() * 100</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    propsChange() &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            num: Math.random() * 100</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setLifeCycleState() &#123;</span><br><span class="line">        this.refs.rLifeCycle.setTheState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forceLifeCycleUpdate() &#123;</span><br><span class="line">        this.refs.rLifeCycle.forceItUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unmountLifeCycle() &#123;</span><br><span class="line">        // 这里卸载父组件也会导致卸载子组件</span><br><span class="line">        React.unmountComponentAtNode(document.getElementById(&quot;container&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parentForceUpdate() &#123;</span><br><span class="line">        this.forceUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;a href=&quot;javascript:;&quot; className=&quot;weui_btn weui_btn_primary&quot; onClick=&#123;this.propsChange.bind(this)&#125;&gt;propsChange&lt;/a&gt;</span><br><span class="line">                &lt;a href=&quot;javascript:;&quot; className=&quot;weui_btn weui_btn_primary&quot; onClick=&#123;this.setLifeCycleState.bind(this)&#125;&gt;setState&lt;/a&gt;</span><br><span class="line">                &lt;a href=&quot;javascript:;&quot; className=&quot;weui_btn weui_btn_primary&quot; onClick=&#123;this.forceLifeCycleUpdate.bind(this)&#125;&gt;forceUpdate&lt;/a&gt;</span><br><span class="line">                &lt;a href=&quot;javascript:;&quot; className=&quot;weui_btn weui_btn_primary&quot; onClick=&#123;this.unmountLifeCycle.bind(this)&#125;&gt;unmount&lt;/a&gt;</span><br><span class="line">                &lt;a href=&quot;javascript:;&quot; className=&quot;weui_btn weui_btn_primary&quot; onClick=&#123;this.parentForceUpdate.bind(this)&#125;&gt;parentForceUpdateWithoutChange&lt;/a&gt;</span><br><span class="line">                &lt;LifeCycle ref=&quot;rLifeCycle&quot; num=&#123;this.state.num&#125;&gt;&lt;/LifeCycle&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">    &lt;Container&gt;&lt;/Container&gt;,</span><br><span class="line">    document.getElementById(&apos;container&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;目前是处于刚学习react阶段，暂时整理如下资料，后续会继续修改和更新&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="react" scheme="kyrie.github.io/categories/react/"/>
    
    
      <category term="react" scheme="kyrie.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝的实现</title>
    <link href="kyrie.github.io/2018/04/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>kyrie.github.io/2018/04/21/深拷贝的实现/</id>
    <published>2018-04-21T11:45:17.000Z</published>
    <updated>2018-05-21T11:54:14.023Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是深拷贝、浅拷贝"><a href="#什么是深拷贝、浅拷贝" class="headerlink" title="什么是深拷贝、浅拷贝"></a>什么是深拷贝、浅拷贝</h4><ul><li>浅拷贝：拷贝的值为引用而非其真实值<br>js中会为引用类型分配在堆内，而我们声明的变量并不是保存着这个对象，而是保存着对象的引用！<br>因此，传入参数时，也是按值传递的。但是，这个值是引用，所以修改同一引用会导致对象的直接变化。<a id="more"></a></li><li>深拷贝：拷贝的值为真实值而非引用。当拷贝的元素是对象是，深拷贝相当于会重新创建一个对象，并对对   象的值一个一个复制过来，而不是仅仅获得该对象的引用值。<h4 id="为什么要深拷贝呢"><a href="#为什么要深拷贝呢" class="headerlink" title="为什么要深拷贝呢"></a>为什么要深拷贝呢</h4>显然，浅拷贝会带来一个很大的问题。就是，如果我复制的值是一个引用地址，那么我通过一个变量去修改这个对象，会导致所有该对象的引用都发生变化。<h4 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h4>如何实现深拷贝呢，采用的就是递归的思想<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj) &#123;</span><br><span class="line">    var newObj = obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">    //obj属于基本数据类型,直接返回obj</span><br><span class="line">    if(typeof obj !== &apos;object&apos;) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    //obj属于数组或对象，遍历它们</span><br><span class="line">        for(var i in obj) &#123;</span><br><span class="line">            newObj[i] = typeof obj[i] === &apos;object&apos; ? deepClone(obj[i]):obj[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考：<a href="https://blog.csdn.net/qq_31628337/article/details/71123754" target="_blank" rel="noopener">https://blog.csdn.net/qq_31628337/article/details/71123754</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是深拷贝、浅拷贝&quot;&gt;&lt;a href=&quot;#什么是深拷贝、浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;什么是深拷贝、浅拷贝&quot;&gt;&lt;/a&gt;什么是深拷贝、浅拷贝&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;浅拷贝：拷贝的值为引用而非其真实值&lt;br&gt;js中会为引用类型分配在堆内，而我们声明的变量并不是保存着这个对象，而是保存着对象的引用！&lt;br&gt;因此，传入参数时，也是按值传递的。但是，这个值是引用，所以修改同一引用会导致对象的直接变化。
    
    </summary>
    
      <category term="深拷贝" scheme="kyrie.github.io/categories/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
    
      <category term="js" scheme="kyrie.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue笔记(上)</title>
    <link href="kyrie.github.io/2018/04/21/vue%E7%AC%94%E8%AE%B0/"/>
    <id>kyrie.github.io/2018/04/21/vue笔记/</id>
    <published>2018-04-21T11:01:17.000Z</published>
    <updated>2018-05-21T09:20:18.773Z</updated>
    
    <content type="html"><![CDATA[<ul><li>先来个链接 <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue 中文网</a></li><li>Vue.js 是一套构建用户界面(UI)的渐进式JavaScript框架<a id="more"></a><h3 id="什么是vue"><a href="#什么是vue" class="headerlink" title="什么是vue"></a>什么是vue</h3>简而言之：Vue.js是一个构建<strong>数据驱动</strong>的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的<strong>数据绑定</strong>和组合的<strong>视图组件</strong>。核心是一个响应的<strong>数据绑定系统</strong>。<br>它有以下几个特点：<blockquote><ul><li>简洁、轻量、组件化、快速、数据驱动、双向数据绑定、指令</li></ul></blockquote><h3 id="学习Vue要转化思想"><a href="#学习Vue要转化思想" class="headerlink" title="学习Vue要转化思想"></a>学习Vue要转化思想</h3><blockquote><ul><li>不要在想着怎么操作DOM，而是想着如何操作数据！(体现数据驱动)</li></ul></blockquote><h3 id="配置安装脚手架"><a href="#配置安装脚手架" class="headerlink" title="配置安装脚手架"></a><a href="https://www.jianshu.com/p/1626b8643676" target="_blank" rel="noopener">配置安装脚手架</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. npm install vue-cli -g  全局安装</span><br><span class="line">2. vue init webpack (文件名:不能为中文)</span><br><span class="line">3. cd (文件名)</span><br><span class="line">4. npm install</span><br><span class="line">5. npm run dev</span><br></pre></td></tr></table></figure></li></ul><p>配置完成之后进入目录就会看到下图结构<br><img src="https://upload-images.jianshu.io/upload_images/3868852-dc56e16bc1ae6b13.png" alt=""></p><h4 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h4><ul><li>注意 1：先在data中声明数据，再使用数据</li><li>注意 2：可以通过 <code>vm.$data</code> 访问到data中的所有属性，或者 <code>vm.msg</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: &apos;大家好，...&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.$data.msg === vm.msg // true</span><br></pre></td></tr></table></figure></li></ul><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul><li>解释：指令 (Directives) 是带有 <code>v-</code> 前缀的特殊属性</li><li>作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li></ul><h5 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h5><ul><li>解释：更新DOM对象的 textContent<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-text=&quot;msg&quot;&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h5><ul><li>解释：更新DOM对象的 innerHTML<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-html=&quot;msg&quot;&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h5><ul><li>作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li><li>语法：<code>v-bind:title=&quot;msg&quot;</code></li><li>简写: <code>title=&quot;msg&quot;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><ul><li>作用：绑定事件</li><li>语法：<code>v-on:click=&quot;say&quot;</code> or <code>v-on:click=&quot;say(&#39;参数&#39;, $event)&quot;</code></li><li>简写：<code>@click=&quot;say&quot;</code></li><li>说明：绑定的事件定义在<code>methods</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h5><ul><li>作用：在表单元素上创建双向数据绑定</li><li>说明：监听用户的输入事件以更新数据</li><li>案例：计算器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;</span><br><span class="line">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><ul><li>作用：基于源数据多次渲染元素或模板块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 1 基础用法 --&gt;</span><br><span class="line">&lt;div v-for=&quot;item in items&quot;&gt;</span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- item 为当前项，index 为索引 --&gt;</span><br><span class="line">&lt;p v-for=&quot;(item, index) in list&quot;&gt;&#123;&#123;item&#125;&#125; -- &#123;&#123;index&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;!-- item 为值，key 为键，index 为索引 --&gt;</span><br><span class="line">&lt;p v-for=&quot;(item, key, index) in obj&quot;&gt;&#123;&#123;item&#125;&#125; -- &#123;&#123;key&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p v-for=&quot;item in 10&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ul><h6 id="key属性"><a href="#key属性" class="headerlink" title="key属性"></a>key属性</h6><ul><li>推荐：使用 <code>v-for</code> 的时候提供 <code>key</code> 属性，以获得性能提升。</li><li>说明：使用 <code>key</code>，VUE会基于 <code>key</code> 的变化重新排列元素顺序，并且会移除 <code>key</code> 不存在的元素。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h5><ul><li><code>.stop</code> 阻止冒泡，调用 <code>event.stopPropagation()</code></li><li><code>.prevent</code> 阻止默认行为，调用 <code>event.preventDefault()</code></li><li><code>.capture</code> 添加事件侦听器时使用事件捕获模式</li><li><code>.self</code> 只当事件在该元素本身（比如不是子元素）触发时，才会触发事件</li><li><code>.once</code> 事件只触发一次</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;先来个链接 &lt;a href=&quot;https://cn.vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue 中文网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vue.js 是一套构建用户界面(UI)的渐进式JavaScript框架
    
    </summary>
    
      <category term="vue" scheme="kyrie.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="kyrie.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>node搭建后台cors跨域配置请求头问题</title>
    <link href="kyrie.github.io/2018/04/15/node%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0cors%E8%B7%A8%E5%9F%9F/"/>
    <id>kyrie.github.io/2018/04/15/node搭建后台cors跨域/</id>
    <published>2018-04-15T01:01:17.000Z</published>
    <updated>2018-05-17T15:45:17.689Z</updated>
    
    <content type="html"><![CDATA[<p>使用node搭建后台时，使用cors跨域，之前在app.js的配置是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myapp.all(&apos;*&apos;, function (req, res, next) &#123;</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">    res.header(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;)</span><br><span class="line">    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>之后在开发中，会出现post请求跨域失败，报错是403，服务器拒绝访问。。。。。但get请求没问题 <a id="more"></a><br>最后更改了cors跨域的配置代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myapp.all(&apos;*&apos;, function(req, res, next) &#123;</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With,X_Requested_With,Content-Type&quot;);</span><br><span class="line">    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>就好了！请教了一位后台开发人员，他说是之前的配置没有兼容全，使用兼容全的代码即可 </p><p>还有：<br>因为img的src属性默认get跨域，所以如果要显示其他服务图片，可直接写请求的网络路径，被请求的服务一般会设置静态资源路径：比如node<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myapp.use(myexpress.static(__dirname + &quot;/public&quot;)); //静态文件的路径配置</span><br><span class="line">myapp.use(&apos;/public/images&apos;,myexpress.static(&quot;public/images&quot;)); //其他服务器请求静态文件的路径配置</span><br></pre></td></tr></table></figure></p><p>第一句是同源策略下访问静态路径，而第二个就是其他服务访问的静态路径配置，这两个是不一样的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用node搭建后台时，使用cors跨域，之前在app.js的配置是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;myapp.all(&amp;apos;*&amp;apos;, function (req, res, next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.header(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.header(&amp;quot;Access-Control-Allow-Headers&amp;quot;, &amp;quot;X-Requested-With&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.header(&amp;quot;Access-Control-Allow-Methods&amp;quot;, &amp;quot;PUT,POST,GET,DELETE,OPTIONS&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.header(&amp;quot;X-Powered-By&amp;quot;, &amp;apos; 3.2.1&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.header(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json;charset=utf-8&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;之后在开发中，会出现post请求跨域失败，报错是403，服务器拒绝访问。。。。。但get请求没问题
    
    </summary>
    
      <category term="node.js" scheme="kyrie.github.io/categories/node-js/"/>
    
    
      <category term="node.js" scheme="kyrie.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue+axios 实现http拦截及路由拦截</title>
    <link href="kyrie.github.io/2018/04/10/Vue+axios%20%E5%AE%9E%E7%8E%B0http%E6%8B%A6%E6%88%AA%E5%8F%8A%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA%20/"/>
    <id>kyrie.github.io/2018/04/10/Vue+axios 实现http拦截及路由拦截 /</id>
    <published>2018-04-10T06:01:17.000Z</published>
    <updated>2018-05-21T09:21:01.925Z</updated>
    
    <content type="html"><![CDATA[<p>每个前端对于Vue都不会陌生,Vue框架是如今最流行的前端框架之一,其势头直追react.最近我用vue做了一个项目,下面便是我从中取得的一点收获.<br>基于现在用vue+webpack搭建项目的文档已经有很多了,我就不再累述了.<br>技术栈<br>vue2.0<br>vue-router<br>axios<br><a id="more"></a><br>拦截器 </p><ul><li>首先我们要明白设置拦截器的目的是什么,当我们需要统一处理http请求和响应时我们通过设置拦截器处理方便很多.</li></ul><p>这个项目我引入了element ui框架,所以我是结合element中loading和message组件来处理的<a href="http://element.eleme.io/#/zh-CN/component/loading#loading-jia-zai" target="_blank" rel="noopener">组件文档</a>.我们可以单独建立一个http的js文件处理axios,再到main.js中引入.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * http配置</span><br><span class="line"> */</span><br><span class="line">// 引入axios以及element ui中的loading和message组件</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import &#123; Loading, Message &#125; from &apos;element-ui&apos;</span><br><span class="line">// 超时时间</span><br><span class="line">axios.defaults.timeout = 5000</span><br><span class="line">// http请求拦截器</span><br><span class="line">var loadinginstace</span><br><span class="line">axios.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">    // element ui Loading方法</span><br><span class="line">    loadinginstace = Loading.service(&#123;fullscreen: true&#125;)</span><br><span class="line">    return config</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    loadinginstace.close()</span><br><span class="line">    Message.error(&#123;</span><br><span class="line">        message: &apos;加载超时&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line">// http响应拦截器</span><br><span class="line">axios.interceptors.response.use(data =&gt; &#123;// 响应成功关闭loading</span><br><span class="line">    loadinginstace.close()</span><br><span class="line">    return data</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    loadinginstace.close()</span><br><span class="line">    Message.error(&#123;</span><br><span class="line">        message: &apos;加载失败&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line">export default axios</span><br></pre></td></tr></table></figure></p><p>这样我们就统一处理了http请求和响应的拦截.当然我们可以根据具体的业务要求更改拦截中的处理.<br>参考:<a href="https://www.cnblogs.com/parkboyoung/p/6761863.html" target="_blank" rel="noopener">https://www.cnblogs.com/parkboyoung/p/6761863.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个前端对于Vue都不会陌生,Vue框架是如今最流行的前端框架之一,其势头直追react.最近我用vue做了一个项目,下面便是我从中取得的一点收获.&lt;br&gt;基于现在用vue+webpack搭建项目的文档已经有很多了,我就不再累述了.&lt;br&gt;技术栈&lt;br&gt;vue2.0&lt;br&gt;vue-router&lt;br&gt;axios&lt;br&gt;
    
    </summary>
    
      <category term="vue" scheme="kyrie.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="kyrie.github.io/tags/vue/"/>
    
      <category term="跨域" scheme="kyrie.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>vue :key属性的作用</title>
    <link href="kyrie.github.io/2018/04/02/vue_key%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>kyrie.github.io/2018/04/02/vue_key属性的作用/</id>
    <published>2018-04-02T01:01:17.000Z</published>
    <updated>2018-05-21T09:20:57.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="key-到底有什么用啊"><a href="#key-到底有什么用啊" class="headerlink" title=":key 到底有什么用啊"></a>:key 到底有什么用啊</h3><p>个人总结：Vue在为了节省DOM操作的性能，使用了重复策略。而在一个特别时，我们不需要重复策略，这时可以通过<code>:key</code>属性来指定不同的值，让它不执行重复策略，实现重新渲染 </p><h4 id="条件渲染中"><a href="#条件渲染中" class="headerlink" title="条件渲染中"></a>条件渲染中</h4><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果允许用户在不同的登录方式之间切换：<br>例如：<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 <code>placeholder</code>这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>现在，每次切换时，输入框都将被重新渲染。注意，<code>&lt;label&gt;</code> 元素仍然会被高效地复用，因为它们没有添加 key 属性 </p><h4 id="V-for-中"><a href="#V-for-中" class="headerlink" title="V-for 中"></a>V-for 中</h4><p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。<br>这个<strong>默认的模式是高效的</strong>，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态</strong> (例如：表单输入值) 的列表渲染输出。<br>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为<strong>每项提供一个唯一 key 属性</strong>。理想的 key 值是每项<strong>都有的且唯一的id</strong>。<br>但它的工作方式类似于一个属性，所以需要用 v-bind 来绑定动态值 (在这里使用简写)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>建议尽可能在使用 <code>v-for</code> 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。<br>因为它是 Vue 识别节点的一个通用机制，key 并不与 <code>v-for</code> 特别关联，key 还具有其他用途，将在以后的开发学习中慢慢接触。<br>另注：:key要放在真正的html元素上，不能放在<code>&lt;template&gt;&lt;/template&gt;</code><br>参考: <a href="https://segmentfault.com/q/1010000009077632/a-1020000009077906" target="_blank" rel="noopener">https://segmentfault.com/q/1010000009077632/a-1020000009077906</a><br>vuejs官网：<a href="https://cn.vuejs.org/v2/guide/list.html#key" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/list.html#key</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;key-到底有什么用啊&quot;&gt;&lt;a href=&quot;#key-到底有什么用啊&quot; class=&quot;headerlink&quot; title=&quot;:key 到底有什么用啊&quot;&gt;&lt;/a&gt;:key 到底有什么用啊&lt;/h3&gt;&lt;p&gt;个人总结：Vue在为了节省DOM操作的性能，使用了重复策略。而在一个特别时，我们不需要重复策略，这时可以通过&lt;code&gt;:key&lt;/code&gt;属性来指定不同的值，让它不执行重复策略，实现重新渲染 &lt;/p&gt;
&lt;h4 id=&quot;条件渲染中&quot;&gt;&lt;a href=&quot;#条件渲染中&quot; class=&quot;headerlink&quot; title=&quot;条件渲染中&quot;&gt;&lt;/a&gt;条件渲染中&lt;/h4&gt;&lt;p&gt;Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果允许用户在不同的登录方式之间切换：&lt;br&gt;例如：
    
    </summary>
    
      <category term="vue" scheme="kyrie.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="kyrie.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>MVX框架模式了解</title>
    <link href="kyrie.github.io/2018/04/01/MVX%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3/"/>
    <id>kyrie.github.io/2018/04/01/MVX框架模式了解/</id>
    <published>2018-04-01T02:01:17.000Z</published>
    <updated>2018-05-21T08:21:39.135Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MVX框架模式：MVC-MVP-MVVM"><a href="#MVX框架模式：MVC-MVP-MVVM" class="headerlink" title="MVX框架模式：MVC+MVP+MVVM"></a>MVX框架模式：MVC+MVP+MVVM</h4><p>1.MVC:</p><blockquote><p>Model(模型)+View(视图)+controller(控制器)，主要是基于分层的目的，让彼此的职责分开。<br>      View通过Controller来和Model联系，Controller是View和Model的协调者，View和Model不直接联系，基本联系都是单向的。<br>        用户User通过控制器Controller来操作模板Model从而达到视图View的变化。<br><a id="more"></a><br>2.MVP:<br>是从MVC模式演变而来的，都是通过Controller/Presenter负责逻辑的处理+Model提供数据+View负责显示。<br>      在MVP中，Presenter完全把View和Model进行了分离，主要的程序逻辑在Presenter里实现。<br>并且，Presenter和View是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更View的时候可以保持Presenter不变。</p></blockquote><p>3.MVVM：</p><blockquote><p>MVVM是把MVC里的Controller和MVP里的Presenter改成了ViewModel。Model+View+ViewModel。<br>       View的变化会自动更新到ViewModel,ViewModel的变化也会自动同步到View上显示。<br>     这种自动同步是因为ViewModel中的属性实现了Observer，当属性变更时都能触发对应的操作。</p></blockquote><p>MVVM模式的框架有：AngularJS+Vue.js</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;MVX框架模式：MVC-MVP-MVVM&quot;&gt;&lt;a href=&quot;#MVX框架模式：MVC-MVP-MVVM&quot; class=&quot;headerlink&quot; title=&quot;MVX框架模式：MVC+MVP+MVVM&quot;&gt;&lt;/a&gt;MVX框架模式：MVC+MVP+MVVM&lt;/h4&gt;&lt;p&gt;1.MVC:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Model(模型)+View(视图)+controller(控制器)，主要是基于分层的目的，让彼此的职责分开。&lt;br&gt;      View通过Controller来和Model联系，Controller是View和Model的协调者，View和Model不直接联系，基本联系都是单向的。&lt;br&gt;        用户User通过控制器Controller来操作模板Model从而达到视图View的变化。&lt;br&gt;
    
    </summary>
    
    
      <category term="vue" scheme="kyrie.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>css居中小技巧</title>
    <link href="kyrie.github.io/2018/03/15/css%E5%B1%85%E4%B8%AD%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>kyrie.github.io/2018/03/15/css居中小技巧/</id>
    <published>2018-03-15T01:56:41.000Z</published>
    <updated>2018-05-17T15:45:07.336Z</updated>
    
    <content type="html"><![CDATA[<p>在我们项目开发中，总会遇到许许多多的水平或者垂直居中问题，这是我在敲代码的时候总结的一些小技巧，以便自己后面的开发学习。</p><h2 id="居中问题"><a href="#居中问题" class="headerlink" title="居中问题"></a>居中问题</h2><p>如果是块级元素，我们可以给块级元素设置一个宽度，然后利用margin:0 auto对其进行水平居中，这算是比较常见的一种；如果是行内元素，可以直接使用text-align:center进行居中。<br><a id="more"></a><br>另外一种用的方法就是绝对定位。通过父元素设置相对定位，子元素设置为绝对定位，然后对子元素进行left：0; top: 0; right: 0; bottom: 0; 接下来是最重要的一点就是 margin:0 auto;便可以通过这种方式实现居中。代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .center&#123;</span><br><span class="line">        position:absolute;</span><br><span class="line">        left:0;</span><br><span class="line">        right:0;</span><br><span class="line">        bottom:0;</span><br><span class="line">        top:0;</span><br><span class="line">        margin: auto auto;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>但是这样的方式在IE7下是不能生效的。那么用另一种方式实现居中<br>解决： 使用另一种方法，top : 50% ,margin-top:-20px; 成功的实现了兼容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .center&#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top:50%;</span><br><span class="line">        left:0;</span><br><span class="line">        right: 0;</span><br><span class="line">        height: 40px;</span><br><span class="line">        margin: -20px auto 0;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>还有一种就是利用的表格的属性进行居中。</p><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>最后这里要介绍的就是利用css3.0的样式，flex布局进行居中:传统的布局方式有三种，哪三种呢：那么分别就是display，position和float，传统的布局方式有个明显缺点，那就是垂直居中不易实现，所以我们就想到了弹性盒子，也就是flex布局，flex布局可以更好地实现响应式布局。<br>任何容器都可以使用flex布局，一旦父元素成为了flex布局，那么它的子元素也就自动成为了容器的成员，也就是flex项目。Flex容器默认存在2根轴线（水平主轴和垂直交叉轴）,布局就是根据这2根轴来排列项目显示的。<br>块级元素：display:flex;<br>内联元素：display:inlne-flex;<br>注意：使用了flex布局后，项目的float、clear、vertical-align都将失去效果。</p><h3 id="flex容器属性"><a href="#flex容器属性" class="headerlink" title="flex容器属性"></a>flex容器属性</h3><p>总共有六个属性：</p><h4 id="1-flex-direction"><a href="#1-flex-direction" class="headerlink" title="1.flex-direction"></a>1.flex-direction</h4><p>设置主轴的方向，默认为水平，从左至右。它的值有四个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: row | row-reverse | column | column-reverse;</span><br></pre></td></tr></table></figure></p><h4 id="2-flex-wrap"><a href="#2-flex-wrap" class="headerlink" title="2.flex-wrap"></a>2.flex-wrap</h4><p>设置项目是否换行排列。<br>nowrap（默认值）：不换行。<br>wrap：换行，第一行在上方。<br>wrap-reverse：换行，第一行在下方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap: nowrap | wrap | wrap-reverse;</span><br></pre></td></tr></table></figure></p><h4 id="3-justify-content"><a href="#3-justify-content" class="headerlink" title="3.justify-content"></a>3.justify-content</h4><p>设置项目的水平对齐方式。<br>flex-start（默认值）：左对齐<br>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目之间的间隔都相等。<br>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure></p><h4 id="4-align-items"><a href="#4-align-items" class="headerlink" title="4.align-items"></a>4.align-items</h4><p>设置项目垂直方向对齐方式。<br>flex-start：交叉轴的起点对齐。<br>flex-end：交叉轴的终点对齐。<br>center：交叉轴的中点对齐。<br>baseline: 项目的第一行文字的基线对齐。<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure></p><h4 id="5-align-content"><a href="#5-align-content" class="headerlink" title="5.align-content"></a>5.align-content</h4><p>当项目定义了横竖2根轴的时候生效，相当于justify-content和align-items的简写。</p><h4 id="6-flex-flow"><a href="#6-flex-flow" class="headerlink" title="6.flex-flow"></a>6.flex-flow</h4><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br></pre></td></tr></table></figure></p><h3 id="flex项目属性"><a href="#flex项目属性" class="headerlink" title="flex项目属性"></a>flex项目属性</h3><h4 id="1-order"><a href="#1-order" class="headerlink" title="1.order"></a>1.order</h4><p>order: <integer>;<br>定义项目的排列顺序，值越小越考前，默认为0。</integer></p><h4 id="2-flex-grow"><a href="#2-flex-grow" class="headerlink" title="2.flex-grow"></a>2.flex-grow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-grow: &lt;number&gt;;</span><br></pre></td></tr></table></figure><p>定义项目的放大比例，默认为0（不放大）。</p><h4 id="3-flex-shrink"><a href="#3-flex-shrink" class="headerlink" title="3.flex-shrink"></a>3.flex-shrink</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-shrink: &lt;number&gt;;</span><br></pre></td></tr></table></figure><p>定义项目的缩小比例，默认为1，如果空间不足湘江将自动缩小。</p><h4 id="4-flex-basis"><a href="#4-flex-basis" class="headerlink" title="4.flex-basis"></a>4.flex-basis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-basis: &lt;length&gt; | auto;</span><br></pre></td></tr></table></figure><p>定义项目主轴空间，相当于设置width，默认为auto。</p><h4 id="5-align-self"><a href="#5-align-self" class="headerlink" title="5.align-self"></a>5.align-self</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p>定义项目的对齐方式。可覆盖align-items。默认值：auto。</p><h4 id="6-flex"><a href="#6-flex" class="headerlink" title="6.flex"></a>6.flex</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]</span><br></pre></td></tr></table></figure><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们项目开发中，总会遇到许许多多的水平或者垂直居中问题，这是我在敲代码的时候总结的一些小技巧，以便自己后面的开发学习。&lt;/p&gt;
&lt;h2 id=&quot;居中问题&quot;&gt;&lt;a href=&quot;#居中问题&quot; class=&quot;headerlink&quot; title=&quot;居中问题&quot;&gt;&lt;/a&gt;居中问题&lt;/h2&gt;&lt;p&gt;如果是块级元素，我们可以给块级元素设置一个宽度，然后利用margin:0 auto对其进行水平居中，这算是比较常见的一种；如果是行内元素，可以直接使用text-align:center进行居中。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="kyrie.github.io/categories/css/"/>
    
    
      <category term="css" scheme="kyrie.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout传递参数问题</title>
    <link href="kyrie.github.io/2018/03/14/setTimeout%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>kyrie.github.io/2018/03/14/setTimeout传递参数问题/</id>
    <published>2018-03-14T11:01:17.000Z</published>
    <updated>2018-05-17T14:34:23.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="setTimeout传参数问题"><a href="#setTimeout传参数问题" class="headerlink" title="setTimeout传参数问题"></a>setTimeout传参数问题</h2><p>无论是<code>window.setTimeout</code>还是<code>window.setInterval</code>，在使用函数名作为调用句柄时都不能带参数，而在 许多场合必须要带参数，这就需要想方法解决。例如对于函数<code>hello(_name)</code>，它用于针对用户名显示欢迎信息：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var userName=&quot;jack&quot;; </span><br><span class="line">//根据用户名显示欢迎信息 </span><br><span class="line">function hello(_name)&#123; </span><br><span class="line">    alert(&quot;hello,&quot;+_name); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时，如果企图使用以下语句来使<code>hello</code>函数延迟3秒执行是不可行的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.setTimeout(hello(userName),3000);</span><br></pre></td></tr></table></figure></p><p>这将使hello函数立即执行，并将返回值作为调用句柄传递给<code>setTimeout</code>函数，其结果并不是程序需要的 。而使用字符串形式可以达到想要的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.setTimeout(&quot;hello(userName)&quot;,3000);</span><br></pre></td></tr></table></figure></p><p>这里的字符串是一段JavaScript代码，其中的<code>userName</code>表示的是变量。但这种写法不够直观，而且有些 场合必须使用函数名，并且所传的变量<strong>必须为全局变量，不能传递局变量</strong><br>下面用一个小技巧来实现带参数函数的调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt; </span><br><span class="line">&lt;!-- </span><br><span class="line">var userName=&quot;jack&quot;; </span><br><span class="line">//根据用户名显示欢迎信息 </span><br><span class="line">function hello(_name)&#123; </span><br><span class="line">       alert(&quot;hello,&quot;+_name); </span><br><span class="line">&#125; </span><br><span class="line">//创建一个函数，用于返回一个无参数函数 </span><br><span class="line">function _hello(_name)&#123; </span><br><span class="line">       return function()&#123; </span><br><span class="line">             hello(_name); </span><br><span class="line">       &#125; </span><br><span class="line">&#125; </span><br><span class="line">window.setTimeout(_hello(userName),3000); </span><br><span class="line">//--&gt; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><strong>此技巧，不管是全局变量，还是局部变量都可以传递</strong><br>这里定义了一个函数<code>_hello</code>，用于接收一个参数，并返回一个不带参数的函数，在这个函数内部使用了 外部函数的参数，从而对其调用，不需要使用参数。在<code>window.setTimeout</code>函数中，使用<code>_hello (userName)</code>来返回一个不带参数的函数句柄，从而实现了参数传递的功能。<br>来自：<a href="http://www.cnblogs.com/chinahnzl/articles/612147.html" target="_blank" rel="noopener">http://www.cnblogs.com/chinahnzl/articles/612147.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;setTimeout传参数问题&quot;&gt;&lt;a href=&quot;#setTimeout传参数问题&quot; class=&quot;headerlink&quot; title=&quot;setTimeout传参数问题&quot;&gt;&lt;/a&gt;setTimeout传参数问题&lt;/h2&gt;&lt;p&gt;无论是&lt;code&gt;window.setTimeout&lt;/code&gt;还是&lt;code&gt;window.setInterval&lt;/code&gt;，在使用函数名作为调用句柄时都不能带参数，而在 许多场合必须要带参数，这就需要想方法解决。例如对于函数&lt;code&gt;hello(_name)&lt;/code&gt;，它用于针对用户名显示欢迎信息：&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="kyrie.github.io/categories/javaScript/"/>
    
    
      <category term="js" scheme="kyrie.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>六顶思考帽~~~~~</title>
    <link href="kyrie.github.io/2018/03/12/%E8%AF%BB%E3%80%8A%E5%85%AD%E9%A1%B6%E6%80%9D%E8%80%83%E5%B8%BD%E3%80%8B/"/>
    <id>kyrie.github.io/2018/03/12/读《六顶思考帽》/</id>
    <published>2018-03-12T05:01:17.000Z</published>
    <updated>2018-05-17T07:38:30.565Z</updated>
    
    <content type="html"><![CDATA[<p>六顶思考帽是指使用六种不同颜色的帽子代表六种不同的思维模式，分为一下几种：</p><p>白色思考帽</p><p>白色是中立而客观的。戴上白色思考帽，人们思考的是关注客观的事实和数据。白色只是陈述问题而已，比如我们看到的新闻，这个季度GDP增长了…%， 戴上白色思考帽只是陈述问题而已，并不会去关心为什么增长了<br><a id="more"></a><br>绿色思考帽<br>绿色象征勃勃生机。绿色思考帽寓意创造力和想象力。例如我们常说的头脑风暴。</p><p>黄色思考帽</p><p>黄色代表价值与肯定。戴上黄色思考帽，人们从正面考虑问题，表达乐观的、满怀希望的、建设性的观点。</p><p>黑色思考帽</p><p>戴上黑色思考帽，人们可以运用否定、怀疑、质疑的看法，合乎逻辑的进行批判，尽情发表负面的意见，找出逻辑上的错误。</p><p>红色思考帽</p><p>红色是情感的色彩。戴上红色思考帽，人们可以表现自己的情绪，人们还可以表达直觉、感受、预感等方面的看法。</p><p>蓝色思考帽</p><p>蓝色思考帽负责控制和调节思维过程。它负责控制各种思考帽的使用顺序，它规划和管理整个思考过程，并负责做出结论。</p><p>六顶思考帽是横向思考方式，并不冲突，当遇到问题时，采用六顶思考帽可以让思路更加清晰</p><p>例如在工作中</p><p>我们使用白色思考帽收集思考各种基础数据</p><p>用绿色思考帽，用创新的思维方式来思考问题，所有的人都可以参与进来，然后提出各自的解决办法，给出好的建议，俗话说 三个臭皮匠抵个诸葛亮，人多想法也多，利用创新思维方式更能找到更好的解决问题的方法</p><p>当收到很多想法和建议时，此时用“黄色思考帽”和“黑色思考帽”，黄色和黑色可以看做相对的，黄色代表优点，黑色代表缺点，通过采用黄色和黑色对每一种想法的危险性和隐患进行分析，从而找到适合的方法，最后采用“红色思考帽”，从经验、直觉上，对已经过滤的问题进行分析、筛选，做出最后决定。</p><p>在思考问题的过程中，还应当随时运用“蓝色思考帽”，对思考的顺序进行调整和控制，甚至有还会停止进行，因为，有的想法可能看起来是正确的，但是执行过程中也可能会进入死胡同，导致无法进行。所以，在整个思考过程中，应随时调换思考帽，随时从不同角度去分析和讨论。</p><p>六顶思考帽，启发我们从不同角度思考同一个问题，在以后的实际生活中尽量运用起来，也许会让自己得到一些改变吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;六顶思考帽是指使用六种不同颜色的帽子代表六种不同的思维模式，分为一下几种：&lt;/p&gt;
&lt;p&gt;白色思考帽&lt;/p&gt;
&lt;p&gt;白色是中立而客观的。戴上白色思考帽，人们思考的是关注客观的事实和数据。白色只是陈述问题而已，比如我们看到的新闻，这个季度GDP增长了…%， 戴上白色思考帽只是陈述问题而已，并不会去关心为什么增长了&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
