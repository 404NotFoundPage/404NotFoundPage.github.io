<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢文锐</title>
  <icon>https://www.gravatar.com/avatar/be0690ad30516f82772b1c75fa56acee</icon>
  <subtitle>朝闻道,夕死可以.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="404NotFoundPage.github.io/"/>
  <updated>2018-05-15T01:50:11.304Z</updated>
  <id>404NotFoundPage.github.io/</id>
  
  <author>
    <name>谢文锐</name>
    <email>xwr204000@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue+axios 实现http拦截及路由拦截</title>
    <link href="404NotFoundPage.github.io/2018/05/15/Vue+axios%20%E5%AE%9E%E7%8E%B0http%E6%8B%A6%E6%88%AA%E5%8F%8A%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA%20/"/>
    <id>404NotFoundPage.github.io/2018/05/15/Vue+axios 实现http拦截及路由拦截 /</id>
    <published>2018-05-15T01:01:17.000Z</published>
    <updated>2018-05-15T01:50:11.304Z</updated>
    
    <content type="html"><![CDATA[<p>每个前端对于Vue都不会陌生,Vue框架是如今最流行的前端框架之一,其势头直追react.最近我用vue做了一个项目,下面便是我从中取得的一点收获.<br>基于现在用vue+webpack搭建项目的文档已经有很多了,我就不再累述了.<br>技术栈<br>vue2.0<br>vue-router<br>axios<br><a id="more"></a><br>拦截器 </p><ul><li>首先我们要明白设置拦截器的目的是什么,当我们需要统一处理http请求和响应时我们通过设置拦截器处理方便很多.</li></ul><p>这个项目我引入了element ui框架,所以我是结合element中loading和message组件来处理的<a href="http://element.eleme.io/#/zh-CN/component/loading#loading-jia-zai" target="_blank" rel="noopener">组件文档</a>.我们可以单独建立一个http的js文件处理axios,再到main.js中引入.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * http配置</span><br><span class="line"> */</span><br><span class="line">// 引入axios以及element ui中的loading和message组件</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import &#123; Loading, Message &#125; from &apos;element-ui&apos;</span><br><span class="line">// 超时时间</span><br><span class="line">axios.defaults.timeout = 5000</span><br><span class="line">// http请求拦截器</span><br><span class="line">var loadinginstace</span><br><span class="line">axios.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">    // element ui Loading方法</span><br><span class="line">    loadinginstace = Loading.service(&#123;fullscreen: true&#125;)</span><br><span class="line">    return config</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    loadinginstace.close()</span><br><span class="line">    Message.error(&#123;</span><br><span class="line">        message: &apos;加载超时&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line">// http响应拦截器</span><br><span class="line">axios.interceptors.response.use(data =&gt; &#123;// 响应成功关闭loading</span><br><span class="line">    loadinginstace.close()</span><br><span class="line">    return data</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    loadinginstace.close()</span><br><span class="line">    Message.error(&#123;</span><br><span class="line">        message: &apos;加载失败&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line">export default axios</span><br></pre></td></tr></table></figure></p><p>这样我们就统一处理了http请求和响应的拦截.当然我们可以根据具体的业务要求更改拦截中的处理.<br>参考:<a href="https://www.cnblogs.com/parkboyoung/p/6761863.html" target="_blank" rel="noopener">https://www.cnblogs.com/parkboyoung/p/6761863.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个前端对于Vue都不会陌生,Vue框架是如今最流行的前端框架之一,其势头直追react.最近我用vue做了一个项目,下面便是我从中取得的一点收获.&lt;br&gt;基于现在用vue+webpack搭建项目的文档已经有很多了,我就不再累述了.&lt;br&gt;技术栈&lt;br&gt;vue2.0&lt;br&gt;vue-router&lt;br&gt;axios&lt;br&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="404NotFoundPage.github.io/tags/Vue/"/>
    
      <category term="跨域" scheme="404NotFoundPage.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>node搭建后台cors跨域配置请求头问题</title>
    <link href="404NotFoundPage.github.io/2018/05/15/hello-world/"/>
    <id>404NotFoundPage.github.io/2018/05/15/hello-world/</id>
    <published>2018-05-15T01:01:17.000Z</published>
    <updated>2018-05-15T01:35:36.444Z</updated>
    
    <content type="html"><![CDATA[<p>使用node搭建后台时，使用cors跨域，之前在app.js的配置是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myapp.all(&apos;*&apos;, function (req, res, next) &#123;</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">    res.header(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;)</span><br><span class="line">    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>之后在开发中，会出现post请求跨域失败，报错是403，服务器拒绝访问。。。。。但get请求没问题 <a id="more"></a><br>最后更改了cors跨域的配置代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myapp.all(&apos;*&apos;, function(req, res, next) &#123;</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With,X_Requested_With,Content-Type&quot;);</span><br><span class="line">    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>就好了！请教了一位后台开发人员，他说是之前的配置没有兼容全，使用兼容全的代码即可 </p><p>还有：<br>因为img的src属性默认get跨域，所以如果要显示其他服务图片，可直接写请求的网络路径，被请求的服务一般会设置静态资源路径：比如node<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myapp.use(myexpress.static(__dirname + &quot;/public&quot;)); //静态文件的路径配置</span><br><span class="line">myapp.use(&apos;/public/images&apos;,myexpress.static(&quot;public/images&quot;)); //其他服务器请求静态文件的路径配置</span><br></pre></td></tr></table></figure></p><p>第一句是同源策略下访问静态路径，而第二个就是其他服务访问的静态路径配置，这两个是不一样的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用node搭建后台时，使用cors跨域，之前在app.js的配置是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;myapp.all(&amp;apos;*&amp;apos;, function (req, res, next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.header(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.header(&amp;quot;Access-Control-Allow-Headers&amp;quot;, &amp;quot;X-Requested-With&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.header(&amp;quot;Access-Control-Allow-Methods&amp;quot;, &amp;quot;PUT,POST,GET,DELETE,OPTIONS&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.header(&amp;quot;X-Powered-By&amp;quot;, &amp;apos; 3.2.1&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.header(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json;charset=utf-8&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;之后在开发中，会出现post请求跨域失败，报错是403，服务器拒绝访问。。。。。但get请求没问题
    
    </summary>
    
    
      <category term="node.js" scheme="404NotFoundPage.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>vue :key属性的作用</title>
    <link href="404NotFoundPage.github.io/2018/05/15/vue_key%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>404NotFoundPage.github.io/2018/05/15/vue_key属性的作用/</id>
    <published>2018-05-15T01:01:17.000Z</published>
    <updated>2018-05-15T02:07:10.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="key-到底有什么用啊"><a href="#key-到底有什么用啊" class="headerlink" title=":key 到底有什么用啊"></a>:key 到底有什么用啊</h3><p>个人总结：Vue在为了节省DOM操作的性能，使用了重复策略。而在一个特别时，我们不需要重复策略，这时可以通过<code>:key</code>属性来指定不同的值，让它不执行重复策略，实现重新渲染 </p><h4 id="条件渲染中"><a href="#条件渲染中" class="headerlink" title="条件渲染中"></a>条件渲染中</h4><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果允许用户在不同的登录方式之间切换：<br>例如：<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 placeholder这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>现在，每次切换时，输入框都将被重新渲染。注意，<label> 元素仍然会被高效地复用，因为它们没有添加 key 属性 </label></p><h4 id="V-for-中"><a href="#V-for-中" class="headerlink" title="V-for 中"></a>V-for 中</h4><p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。<br>这个<strong>默认的模式是高效的</strong>，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态</strong> (例如：表单输入值) 的列表渲染输出。<br>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为<strong>每项提供一个唯一 key 属性</strong>。理想的 key 值是每项<strong>都有的且唯一的id</strong>。<br>但它的工作方式类似于一个属性，所以需要用 v-bind 来绑定动态值 (在这里使用简写)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。<br>因为它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途，将在以后的开发学习中慢慢接触。<br>另注：:key要放在真正的html元素上，不能放在<code>&lt;template&gt;&lt;/template&gt;</code><br>参考: <a href="https://segmentfault.com/q/1010000009077632/a-1020000009077906" target="_blank" rel="noopener">https://segmentfault.com/q/1010000009077632/a-1020000009077906</a><br>vuejs官网：<a href="https://cn.vuejs.org/v2/guide/list.html#key" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/list.html#key</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;key-到底有什么用啊&quot;&gt;&lt;a href=&quot;#key-到底有什么用啊&quot; class=&quot;headerlink&quot; title=&quot;:key 到底有什么用啊&quot;&gt;&lt;/a&gt;:key 到底有什么用啊&lt;/h3&gt;&lt;p&gt;个人总结：Vue在为了节省DOM操作的性能，使用了重复策略。而在一个特别时，我们不需要重复策略，这时可以通过&lt;code&gt;:key&lt;/code&gt;属性来指定不同的值，让它不执行重复策略，实现重新渲染 &lt;/p&gt;
&lt;h4 id=&quot;条件渲染中&quot;&gt;&lt;a href=&quot;#条件渲染中&quot; class=&quot;headerlink&quot; title=&quot;条件渲染中&quot;&gt;&lt;/a&gt;条件渲染中&lt;/h4&gt;&lt;p&gt;Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果允许用户在不同的登录方式之间切换：&lt;br&gt;例如：
    
    </summary>
    
    
      <category term="Vue" scheme="404NotFoundPage.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>css居中小技巧</title>
    <link href="404NotFoundPage.github.io/2018/05/15/css%E5%B1%85%E4%B8%AD%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>404NotFoundPage.github.io/2018/05/15/css居中小技巧/</id>
    <published>2018-05-15T00:56:41.000Z</published>
    <updated>2018-05-15T01:39:23.154Z</updated>
    
    <content type="html"><![CDATA[<p>在我们项目开发中，总会遇到许许多多的水平或者垂直居中问题，这是我在敲代码的时候总结的一些小技巧，以便自己后面的开发学习。</p><h2 id="居中问题"><a href="#居中问题" class="headerlink" title="居中问题"></a>居中问题</h2><p>如果是块级元素，我们可以给块级元素设置一个宽度，然后利用margin:0 auto对其进行水平居中，这算是比较常见的一种；如果是行内元素，可以直接使用text-align:center进行居中。<br><a id="more"></a><br>另外一种用的方法就是绝对定位。通过父元素设置相对定位，子元素设置为绝对定位，然后对子元素进行left：0; top: 0; right: 0; bottom: 0; 接下来是最重要的一点就是 margin:0 auto;便可以通过这种方式实现居中。代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .center&#123;</span><br><span class="line">        position:absolute;</span><br><span class="line">        left:0;</span><br><span class="line">        right:0;</span><br><span class="line">        bottom:0;</span><br><span class="line">        top:0;</span><br><span class="line">        margin: auto auto;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>但是这样的方式在IE7下是不能生效的。那么用另一种方式实现居中<br>解决： 使用另一种方法，top : 50% ,margin-top:-20px; 成功的实现了兼容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .center&#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top:50%;</span><br><span class="line">        left:0;</span><br><span class="line">        right: 0;</span><br><span class="line">        height: 40px;</span><br><span class="line">        margin: -20px auto 0;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>还有一种就是利用的表格的属性进行居中。</p><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>最后这里要介绍的就是利用css3.0的样式，flex布局进行居中:传统的布局方式有三种，哪三种呢：那么分别就是display，position和float，传统的布局方式有个明显缺点，那就是垂直居中不易实现，所以我们就想到了弹性盒子，也就是flex布局，flex布局可以更好地实现响应式布局。<br>任何容器都可以使用flex布局，一旦父元素成为了flex布局，那么它的子元素也就自动成为了容器的成员，也就是flex项目。Flex容器默认存在2根轴线（水平主轴和垂直交叉轴）,布局就是根据这2根轴来排列项目显示的。<br>块级元素：display:flex;<br>内联元素：display:inlne-flex;<br>注意：使用了flex布局后，项目的float、clear、vertical-align都将失去效果。</p><h3 id="flex容器属性"><a href="#flex容器属性" class="headerlink" title="flex容器属性"></a>flex容器属性</h3><p>总共有六个属性：</p><h4 id="1-flex-direction"><a href="#1-flex-direction" class="headerlink" title="1.flex-direction"></a>1.flex-direction</h4><p>设置主轴的方向，默认为水平，从左至右。它的值有四个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: row | row-reverse | column | column-reverse;</span><br></pre></td></tr></table></figure></p><h4 id="2-flex-wrap"><a href="#2-flex-wrap" class="headerlink" title="2.flex-wrap"></a>2.flex-wrap</h4><p>设置项目是否换行排列。<br>nowrap（默认值）：不换行。<br>wrap：换行，第一行在上方。<br>wrap-reverse：换行，第一行在下方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap: nowrap | wrap | wrap-reverse;</span><br></pre></td></tr></table></figure></p><h4 id="3-justify-content"><a href="#3-justify-content" class="headerlink" title="3.justify-content"></a>3.justify-content</h4><p>设置项目的水平对齐方式。<br>flex-start（默认值）：左对齐<br>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目之间的间隔都相等。<br>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure></p><h4 id="4-align-items"><a href="#4-align-items" class="headerlink" title="4.align-items"></a>4.align-items</h4><p>设置项目垂直方向对齐方式。<br>flex-start：交叉轴的起点对齐。<br>flex-end：交叉轴的终点对齐。<br>center：交叉轴的中点对齐。<br>baseline: 项目的第一行文字的基线对齐。<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure></p><h4 id="5-align-content"><a href="#5-align-content" class="headerlink" title="5.align-content"></a>5.align-content</h4><p>当项目定义了横竖2根轴的时候生效，相当于justify-content和align-items的简写。</p><h4 id="6-flex-flow"><a href="#6-flex-flow" class="headerlink" title="6.flex-flow"></a>6.flex-flow</h4><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br></pre></td></tr></table></figure></p><h3 id="flex项目属性"><a href="#flex项目属性" class="headerlink" title="flex项目属性"></a>flex项目属性</h3><h4 id="1-order"><a href="#1-order" class="headerlink" title="1.order"></a>1.order</h4><p>order: <integer>;<br>定义项目的排列顺序，值越小越考前，默认为0。</integer></p><h4 id="2-flex-grow"><a href="#2-flex-grow" class="headerlink" title="2.flex-grow"></a>2.flex-grow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-grow: &lt;number&gt;;</span><br></pre></td></tr></table></figure><p>定义项目的放大比例，默认为0（不放大）。</p><h4 id="3-flex-shrink"><a href="#3-flex-shrink" class="headerlink" title="3.flex-shrink"></a>3.flex-shrink</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-shrink: &lt;number&gt;;</span><br></pre></td></tr></table></figure><p>定义项目的缩小比例，默认为1，如果空间不足湘江将自动缩小。</p><h4 id="4-flex-basis"><a href="#4-flex-basis" class="headerlink" title="4.flex-basis"></a>4.flex-basis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-basis: &lt;length&gt; | auto;</span><br></pre></td></tr></table></figure><p>定义项目主轴空间，相当于设置width，默认为auto。</p><h4 id="5-align-self"><a href="#5-align-self" class="headerlink" title="5.align-self"></a>5.align-self</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p>定义项目的对齐方式。可覆盖align-items。默认值：auto。</p><h4 id="6-flex"><a href="#6-flex" class="headerlink" title="6.flex"></a>6.flex</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]</span><br></pre></td></tr></table></figure><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们项目开发中，总会遇到许许多多的水平或者垂直居中问题，这是我在敲代码的时候总结的一些小技巧，以便自己后面的开发学习。&lt;/p&gt;
&lt;h2 id=&quot;居中问题&quot;&gt;&lt;a href=&quot;#居中问题&quot; class=&quot;headerlink&quot; title=&quot;居中问题&quot;&gt;&lt;/a&gt;居中问题&lt;/h2&gt;&lt;p&gt;如果是块级元素，我们可以给块级元素设置一个宽度，然后利用margin:0 auto对其进行水平居中，这算是比较常见的一种；如果是行内元素，可以直接使用text-align:center进行居中。&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="404NotFoundPage.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>六顶思考帽~~~~~</title>
    <link href="404NotFoundPage.github.io/2018/05/13/%E8%AF%BB%E3%80%8A%E5%85%AD%E9%A1%B6%E6%80%9D%E8%80%83%E5%B8%BD%E3%80%8B/"/>
    <id>404NotFoundPage.github.io/2018/05/13/读《六顶思考帽》/</id>
    <published>2018-05-13T01:01:17.000Z</published>
    <updated>2018-05-15T02:54:09.185Z</updated>
    
    <content type="html"><![CDATA[<p>六顶思考帽是指使用六种不同颜色的帽子代表六种不同的思维模式，分为一下几种：</p><p>白色思考帽</p><p>白色是中立而客观的。戴上白色思考帽，人们思考的是关注客观的事实和数据。白色只是陈述问题而已，比如我们看到的新闻，这个季度GDP增长了…%， 戴上白色思考帽只是陈述问题而已，并不会去关心为什么增长了<br><a id="more"></a><br>绿色思考帽<br>绿色象征勃勃生机。绿色思考帽寓意创造力和想象力。例如我们常说的头脑风暴。</p><p>黄色思考帽</p><p>黄色代表价值与肯定。戴上黄色思考帽，人们从正面考虑问题，表达乐观的、满怀希望的、建设性的观点。</p><p>黑色思考帽</p><p>戴上黑色思考帽，人们可以运用否定、怀疑、质疑的看法，合乎逻辑的进行批判，尽情发表负面的意见，找出逻辑上的错误。</p><p>红色思考帽</p><p>红色是情感的色彩。戴上红色思考帽，人们可以表现自己的情绪，人们还可以表达直觉、感受、预感等方面的看法。</p><p>蓝色思考帽</p><p>蓝色思考帽负责控制和调节思维过程。它负责控制各种思考帽的使用顺序，它规划和管理整个思考过程，并负责做出结论。</p><p>六顶思考帽是横向思考方式，并不冲突，当遇到问题时，采用六顶思考帽可以让思路更加清晰</p><p>例如在工作中</p><p>我们使用白色思考帽收集思考各种基础数据</p><p>用绿色思考帽，用创新的思维方式来思考问题，所有的人都可以参与进来，然后提出各自的解决办法，给出好的建议，俗话说 三个臭皮匠抵个诸葛亮，人多想法也多，利用创新思维方式更能找到更好的解决问题的方法</p><p>当收到很多想法和建议时，此时用“黄色思考帽”和“黑色思考帽”，黄色和黑色可以看做相对的，黄色代表优点，黑色代表缺点，通过采用黄色和黑色对每一种想法的危险性和隐患进行分析，从而找到适合的方法，最后采用“红色思考帽”，从经验、直觉上，对已经过滤的问题进行分析、筛选，做出最后决定。</p><p>在思考问题的过程中，还应当随时运用“蓝色思考帽”，对思考的顺序进行调整和控制，甚至有还会停止进行，因为，有的想法可能看起来是正确的，但是执行过程中也可能会进入死胡同，导致无法进行。所以，在整个思考过程中，应随时调换思考帽，随时从不同角度去分析和讨论。</p><p>六顶思考帽，启发我们从不同角度思考同一个问题，在以后的实际生活中尽量运用起来，也许会让自己得到一些改变吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;六顶思考帽是指使用六种不同颜色的帽子代表六种不同的思维模式，分为一下几种：&lt;/p&gt;
&lt;p&gt;白色思考帽&lt;/p&gt;
&lt;p&gt;白色是中立而客观的。戴上白色思考帽，人们思考的是关注客观的事实和数据。白色只是陈述问题而已，比如我们看到的新闻，这个季度GDP增长了…%， 戴上白色思考帽只是陈述问题而已，并不会去关心为什么增长了&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
